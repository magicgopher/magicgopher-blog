---
title: 面向对象编程-下篇
author: MagicGopher
keywords: Java, Java基础, 面向对象, 继承, 抽象类, 多态, 接口
description: 介绍 Java 中的面向对象，包括封装、继承和多态，以及这些概念在实际开发中的应用场景。
editLink: false
---

# 面向对象编程-下篇

## 抽象类

Java抽象类是一种使用 abstract 关键字修饰的特殊类，它不能被实例化。抽象类的主要作用是定义一组共同特征的类结构，并被其他类继承以实现其方法。抽象类可以包含普通方法、抽象方法（无方法体）、构造方法、成员变量等，但必须至少包含一个抽象方法，否则就没有定义抽象类的必要。

### abstract 关键字

使用 `abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

定义格式：

```java
访问修饰符 abstract 返回值类型 方法名(参数列表);
```

示例：

```java
public abstract void show();
```

如果一个类中包含抽象方法，那么这个类必须是抽象类，否则会报错。

定义格式：

```java
abstract class 类名 {

}
```

示例：

```java
abstract class Animal {
    public abstract void eat();
}
```

### 抽象类的使用

继承抽象类的子类必须重写父类所有抽象方法。否则，该子类也必须声明位抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不创建对象。

示例：

::: code-group
```java [AbstractTest01]
public class AbstractTest01 {
    public static void main(String[] args) {
        // 创建子类对象
        Cat c = new Cat();

        // 调用run方法
        c.run();
    }
}
```

```java [Animal]
// 抽象类
public abstract class Animal {
    public abstract void run();
}
```

```java [Cat]
// 子类，继承抽象类
public class Cat extends Animal {

    @Override
    public void run() {
        System.out.println("猫在跑...");
    }
}
```
:::

输出结果：

```text
猫在跑...
```

::: warning 注意事项
1. 抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类的子类，必须重写抽象父类中的所有抽象方法，否则，编译无法通过而报错。除非子类也是抽象类。
:::

## 接口

Java接口是一种完全抽象的类型，它定义了一组方法签名（和常量），但不包含方法的具体实现。接口充当了一个契约，规定实现它的类必须提供所有方法的实现，从而允许不同类的对象通过相同的界面进行通信。接口通过 interface 关键字定义，可以实现多继承，以模拟多重继承的能力，增强了代码的灵活性、可扩展性和可维护性。

### 接口的定义格式

定义格式：

```java
public interface 接口名 {
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

#### 含有抽象方法

抽象方法：使用 `abstract` 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

示例：

```java
public interface InterfaceA {
    public abstract void methodA1();
}
```

#### 含有默认方法

默认方法：使用 `default` 关键字修饰，不可以省略，供子类调用或者子类重写。

示例：

```java
public interface Greeting {

    // 1. 抽象方法（必须实现）
    String getName();

    // 2. 默认方法（default）：提供默认实现
    default void sayHello() {
        System.out.println("Hello, " + getName() + "!");
    }

    // 3. 另一个默认方法：复用逻辑
    default void sayGoodbye() {
        System.out.println("Goodbye, " + getName() + "! See you again!");
    }

    // 4. 默认方法也可以调用其他默认方法
    default void greet() {
        sayHello();
        sayGoodbye();
    }

    // 5. 静态方法（顺便演示）
    static void welcome() {
        System.out.println("Welcome to the system!");
    }
}
```

#### 含有静态方法

静态方法：使用 `static` 关键字修饰，供接口直接调用。

示例：

```java
public interface MathUtils {

    // 1. 静态方法：计算两个数的最大公约数（GCD）
    static int gcd(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // 2. 静态方法：判断是否为质数
    static boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }
        return true;
    }

    // 3. 静态方法：格式化输出
    static void printResult(String operation, int result) {
        System.out.println(operation + " 结果: " + result);
    }

    // （可选）默认方法，展示如何调用静态方法
    default void checkGcdAndPrime(int x, int y) {
        int g = gcd(x, y);  // 调用静态方法
        printResult("GCD(" + x + ", " + y + ")", g);

        if (isPrime(g)) {
            System.out.println(g + " 是质数！");
        } else {
            System.out.println(g + " 不是质数");
        }
    }
}
```

#### 含有私有方法

私有方法：使用 `private` 修饰，供接口中的默认方法或者静态方法调用。

```java
// 定义接口
public interface Calculator {

    // 私有静态方法：只能接口内部用
    private static double round(double value) {
        return Math.round(value * 100.0) / 100.0;  // 保留两位小数
    }

    // 私有静态方法：复用逻辑
    private static boolean isPositive(double num) {
        return num > 0;
    }

    // 默认方法1：使用私有静态方法
    default double add(double a, double b) {
        double result = a + b;
        System.out.println("加法: " + a + " + " + b + " = " + result);
        return round(result);  // 使用私有静态方法
    }

    // 默认方法2：也使用同一个 round
    default double multiply(double a, double b) {
        double result = a * b;
        System.out.println("乘法: " + a + " * " + b + " = " + result);
        return round(result);
    }

    // 静态方法：也可以调用私有静态方法
    static void printIfPositive(double num) {
        if (isPositive(num)) {  // 使用私有静态方法
            System.out.println(num + " 是正数");
        } else {
            System.out.println(num + " 不是正数");
        }
    }
}
```

### 实现接口

#### 实现的概述

类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

非抽象子类实现接口：

1. 必须重写接口中的所有抽象方法。
2. 继承了接口的默认方法，即可以直接调用，也可以重写。

语法格式：

```java
class 类名 implements 接口名 {
    // 重写接口中的抽象方法【必须】
    // 重写接口中的默认方法【可选】
}
```

#### 抽象方法的使用

定义的接口：

```java
// 定义的接口
public interface LiveAble {
    // 定义的抽象方法
    // 接口中的抽象方法public abstract是可以省略不写的
    public abstract void eat();
    public abstract void sleep();
}
```

实现接口的实现类：

```java
public class Cat implements LiveAble {
    
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    @Override
    public void sleep() {
        System.out.println("猫睡觉");
    }
}
```

#### 默认方法的使用

接口中的默认方法可以继承，可以重写，二选择一，但是只能通过实现类的对象来调用。

继承默认方法示例：

::: code-group
```java [LiveAble]
public interface LiveAble {
    public default void fly() {
        System.out.println("天上飞");
    }
}
```

```java [Bird]
public class Bird implements LiveAble {
    // 继承接口中的默认方法，什么都不写，直接调用
}
```

```java [Demo01Test]
public class Demo01Test {
    public static void main(String[] args) {
        // 创建子类对象
        Bird b = new Bird();
        // 调用默认方法
        b.fly();
    }
}
```
:::

输出结果：

```
天上飞
```

重写默认方法示例：

::: code-group
```java [LiveAble]
public interface LiveAble {
    public default void fly() {
        System.out.println("天上飞");
    }
}
```

```java [Bird]
public class Bird implements LiveAble {
    // 重写接口中的默认方法
    @Override
    public void fly() {
        System.out.println("极速的飞");
    }
}
```

```java [Demo01Test]
public class Demo01Test {
    public static void main(String[] args) {
        // 创建子类对象
        Bird b = new Bird();
        // 调用默认方法
        b.fly();
    }
}
```
:::

输出结果：

```
极速的飞
```

#### 静态方法的使用

静态与 `.class` 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用。

示例：

::: code-group
```java [LiveAble]
public interface LiveAble {

    // 接口静态方法
    public static void run() {
        System.out.println("跑...");
    }
}
```

```java [Animal]
public class Animal implements LiveAble {
    // 无法重写静态方法
}
```

```java [Demo02Test]
public class Demo02Test {
    public static void main(String[] args) {
        // Animal.run(); // 错误❌ 无法继承方法，也无法调用
        // 调用接口中的静态方法
        LiveAble.run();
    }
}
```
:::

输出结果：

```text
跑...
```

#### 私有方法的使用

- 私有方法：只有默认方法可以调用。
- 私有静态方法：默认方法和静态方法可以调用。

如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

示例：

```java
public interface LiveAble {

    // 默认方法
    default void func1() {
        func2(); // 调用接口私有方法
        func3();
    }

    // 接口私有方法
    private void func2() {
        System.out.println("func2 run...");
    }

    // 接口私有方法
    private void func3() {
        System.out.println("func3 run...");
    }
}
```

### 接口多实现

在继承中，一个类只能继承一个父类，对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现，并且，一个类能继承一个父类，同时实现多个接口。

语法格式：

```java
class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【不重名时可选】
}
```

#### 抽象方法

接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。

示例：

::: code-group
```java [接口A]
public interface A {
    public abstract void show1();
    public abstract void show2();
}
```

```java [接口B]
public interface B {
    public abstract void show3();
    public abstract void show4();
}
```

```java [实现类]
public class C implements A, B {
    @Override
    public void show1() {
        System.out.println("重写接口A的show1()方法");
    }

    @Override
    public void show2() {
        System.out.println("重写接口A的show2()方法");
    }

    @Override
    public void show3() {
        System.out.println("重写接口B的show3()方法");
    }

    @Override
    public void show4() {
        System.out.println("重写接口B的show4()方法");
    }
}
```
:::

#### 默认方法

接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。

示例：

::: code-group
```java [接口A]
public interface A {
    public default void methodA() {
        System.out.println("interface A methodA()");
    }

    public default void method() {
        System.out.println("interface A method()");
    }
}
```

```java [接口B]
public interface B {
    public default void methodB() {
        System.out.println("interface B methodB()");
    }

    public default void method() {
        System.out.println("interface B method()");
    }
}
```

```java [实现类C]
public class C implements A, B {

    @Override
    public void method() {
        System.out.println("C class Override method()");
    }
}
```
:::

#### 静态方法

接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

示例：

::: code-group
```java [接口1]
public interface Printer {
    static void print(String msg) {
        System.out.println("Printer: " + msg.toUpperCase());
    }
}
```

```java [接口2]
public interface Logger {
    static void print(String msg) {
        System.out.println("Logger: [" + msg + "]");
    }
}
```

```java [接口3]
public interface Debugger {
    static void print(String msg) {
        System.out.println("Debugger: >>> " + msg + " <<<");
    }
}
```

```java [实现类]
public class MultiTool implements Printer, Logger, Debugger {

    public void test() {
        // 必须用 接口名.方法名() 调用，清晰无歧义
        Printer.print("hello");     // Printer: HELLO
        Logger.print("启动成功");   // Logger: [启动成功]
        Debugger.print("debug mode"); // Debugger: >>> debug mode <<<
    }
}
```

```java [测试代码]
public class TestMain {
    public static void main(String[] args) {
        MultiTool tool = new MultiTool();
        tool.test();

        System.out.println("---");

        // 也可以直接通过接口名调用
        Printer.print("直接调用");
        Logger.print("日志记录");
        Debugger.print("断点信息");
    }
}
```
:::

#### 优先级问题

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。

示例：

::: code-group
```java [定义接口]
public interface A {

    public default void methodA() {
        System.out.println("AAA");
    }
}
```

```java [定义父类]
public class D {

    public void methodA() {
        System.out.println("DDD");
    }
}
```

```java [定义子类]
public class C extends D implements A {
    // 未重写methodA方法
}
```

```java [测试代码]
public class TestMain {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
```
:::

输出结果：

```text
DDD
```

#### 接口多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。

示例：

```java
// 第一个接口：定义飞行能力
public interface Flyable {
    void fly();
    default void land() {
        System.out.println("正在降落...");
    }
}

// 第二个接口：定义游泳能力
public interface Swimmable {
    void swim();
}

// 第三个接口：继承 Flyable 和 Swimmable，实现多继承
public interface Amphibious extends Flyable, Swimmable {
    // 可以添加新的抽象方法
    void dive();
}

// 实现类：实现 Amphibious 接口，间接实现多继承
public class Duck implements Amphibious {
    
    @Override
    public void fly() {
        System.out.println("鸭子在飞翔");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在游泳");
    }
    
    @Override
    public void dive() {
        System.out.println("鸭子潜入水下");
    }
}

// 测试类
public class TestMain {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly();   // 输出: 鸭子在飞翔
        duck.swim();  // 输出: 鸭子在游泳
        duck.dive();  // 输出: 鸭子潜入水下
        duck.land();  // 输出: 正在降落... (继承自 Flyable 的默认方法)
    }
}
``` 

## 多态

### 概述

Java多态是指同一个方法在不同对象上可以有不同的行为，即允许使用父类类型的引用指向子类对象，并在运行时根据实际对象的类型来调用相应的方法。这是Java面向对象三大特性之一，其核心在于 “向上转型”和“方法重写”，从而实现了代码的灵活性和可扩展性。

多态：是指同一行为，具有多种不同的表现形式。

多态的前提：

- 继承或者实现【二选一】
- 方法的重写【意义体现：不重写，无意义】
- 父类引用指向子类对象【格式表现】

### 多态的体现

多态体现的语法格式：

```java
父类类型 变量名 = new 子类对象;
变量名.方法名();
```

> 父类类型：指的是子类继承的父类类型，或者实现的父接口类型。

示例：

```java
Animal animal = new Cat();
animal.run();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后的方法。

示例：

::: code-group
```java [定义父类]
// 抽象类
public abstract class Animal {
    public abstract void eat();
}
```

```java [定义子类]
public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

```java [定义子类]
public class Dog extends Animal {

    @Override
    public void eat() {
        System.out.println("吃骨头");
    }
}
```

```java [测试类]
public class TestMain {
    public static void main(String[] args) {
        // 多态的形式创建对象
        Animal a1 = new Cat();
        // 调用的是 Cat 的 eat() 方法
        a1.eat();  // 输出：吃鱼

        // 多态的形式创建对象
        Animal a2 = new Dog();
        // 调用的是 Dog 的 eat() 方法
        a2.eat();  // 输出：吃骨头
    }
}
```
:::

### 多态的好处

实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。

示例：

::: code-group
```java [定义父类]
public abstract class Animal {
    // 抽象方法
    public abstract void eat();
}
```

```java [定义子类]
public class Cat extends Animal {

    // 重写父类的抽象方法
    @Override
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

```java [定义子类]
public class Dog extends Animal {

    // 重写父类的抽象方法
    @Override
    public void eat() {
        System.out.println("吃骨头");
    }
}
```

```java [测试类]
public class TestMain {
    public static void main(String[] args) {
        // 创建对象
        Cat cat = new Cat();
        Dog dog = new Dog();

        // 调用showCatEat
        showCatEat(cat);
        // 调用showDogEat
        showDogEat(dog);
        
        /**
         * 以上两个方法，均可以被showAnimalEat(Animal a)方法所替代
         * 而且执行效果一致
         */
        showAnimalEat(cat);
        showAnimalEat(dog);
    }

    public static void showCatEat(Cat c) {
        c.eat();
    }

    public static void showDogEat(Dog d) {
        d.eat();
    }

    public static void showAnimalEat(Animal a) {
        a.eat();
    }
}
```
:::

示例说明：

- 由于多态特性的支持 `showAnimalEat()` 方法的Animal类型，是 `Cat` 和 `Dog` 的父类类型，父类类型接收子类对象，当然可以把 `Cat` 对象和 `Dog` 对象，传递给方法。
- 当 `eat()` 方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与 `showCatEat()`、`showDogEat()` 方法一致，所以 `showAnimalEat()` 完全可以替代以上两方法。
- 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写 `showXxxEat()` 方法了，直接使用 `showAnimalEat()` 都可以完成。

### 多态的两种形式

| 形式 | 说明 | 示例 |
| :-- | :-- | :-- |
| 编译时多态（静态多态） | 方法重载（Overloading） | `add(int a, int b)` 和 `add(double a, double b)` |
| 运行时多态（动态多态） | 方法重写（Overriding） + 继承 + 向上转型 | 父类引用调用子类重写的方法 |

> Java 中真正意义的多态指的是运行时多态（基于方法重写）。

### 运行时多态的三个必要条件

要实现运行时多态，必须同时满足以下三个条件：

1. 继承关系：子类继承父类（或者实现接口）
2. 方法重写：子类重写父类的方法（@Override）
3. 向上转型：父类引用指向子类对象

示例：

```java
class Animal {
    public void makeSound() {
        System.out.println("动物叫声");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪！");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵！");
    }
}

// 使用多态
public class Test {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // 向上转型
        Animal a2 = new Cat();

        a1.makeSound();  // 输出：汪汪！
        a2.makeSound();  // 输出：喵喵！
    }
}
```

### 向上转型

向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。

当父类引用指向一个子类对象时，便是向上转型。

语法格式：

```java
父类类型 变量名 = new 子类类型();
```

示例：

```java
Animal animal = new Cat();
```

::: tip 提示
文档正在更新中...
:::

## 参考资料

- [菜鸟教程](https://www.runoob.com)
- [C语言中文网-Java学习教程](https://c.biancheng.net/java/)