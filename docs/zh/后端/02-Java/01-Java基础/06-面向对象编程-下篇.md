---
title: 面向对象编程-下篇
author: MagicGopher
keywords: Java, Java基础, 面向对象, 继承, 抽象类, 多态, 接口
description: 介绍 Java 中的面向对象，包括封装、继承和多态，以及这些概念在实际开发中的应用场景。
editLink: false
---

# 面向对象编程-下篇

## 接口

Java接口是一种完全抽象的类型，它定义了一组方法签名（和常量），但不包含方法的具体实现。接口充当了一个契约，规定实现它的类必须提供所有方法的实现，从而允许不同类的对象通过相同的界面进行通信。接口通过 interface 关键字定义，可以实现多继承，以模拟多重继承的能力，增强了代码的灵活性、可扩展性和可维护性。

### 接口的定义格式

定义格式：

```java
public interface 接口名 {
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

#### 含有抽象方法

抽象方法：使用 `abstract` 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

示例：

```java
public interface InterfaceA {
    public abstract void methodA1();
}
```

#### 含有默认方法

默认方法：使用 `default` 关键字修饰，不可以省略，供子类调用或者子类重写。

示例：

```java
public interface Greeting {

    // 1. 抽象方法（必须实现）
    String getName();

    // 2. 默认方法（default）：提供默认实现
    default void sayHello() {
        System.out.println("Hello, " + getName() + "!");
    }

    // 3. 另一个默认方法：复用逻辑
    default void sayGoodbye() {
        System.out.println("Goodbye, " + getName() + "! See you again!");
    }

    // 4. 默认方法也可以调用其他默认方法
    default void greet() {
        sayHello();
        sayGoodbye();
    }

    // 5. 静态方法（顺便演示）
    static void welcome() {
        System.out.println("Welcome to the system!");
    }
}
```

#### 含有静态方法

静态方法：使用 `static` 关键字修饰，供接口直接调用。

示例：

```java
public interface MathUtils {

    // 1. 静态方法：计算两个数的最大公约数（GCD）
    static int gcd(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // 2. 静态方法：判断是否为质数
    static boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }
        return true;
    }

    // 3. 静态方法：格式化输出
    static void printResult(String operation, int result) {
        System.out.println(operation + " 结果: " + result);
    }

    // （可选）默认方法，展示如何调用静态方法
    default void checkGcdAndPrime(int x, int y) {
        int g = gcd(x, y);  // 调用静态方法
        printResult("GCD(" + x + ", " + y + ")", g);

        if (isPrime(g)) {
            System.out.println(g + " 是质数！");
        } else {
            System.out.println(g + " 不是质数");
        }
    }
}
```

#### 含有私有方法

私有方法：使用 `private` 修饰，供接口中的默认方法或者静态方法调用。

```java
// 定义接口
public interface Calculator {

    // 私有静态方法：只能接口内部用
    private static double round(double value) {
        return Math.round(value * 100.0) / 100.0;  // 保留两位小数
    }

    // 私有静态方法：复用逻辑
    private static boolean isPositive(double num) {
        return num > 0;
    }

    // 默认方法1：使用私有静态方法
    default double add(double a, double b) {
        double result = a + b;
        System.out.println("加法: " + a + " + " + b + " = " + result);
        return round(result);  // 使用私有静态方法
    }

    // 默认方法2：也使用同一个 round
    default double multiply(double a, double b) {
        double result = a * b;
        System.out.println("乘法: " + a + " * " + b + " = " + result);
        return round(result);
    }

    // 静态方法：也可以调用私有静态方法
    static void printIfPositive(double num) {
        if (isPositive(num)) {  // 使用私有静态方法
            System.out.println(num + " 是正数");
        } else {
            System.out.println(num + " 不是正数");
        }
    }
}
```

### 实现接口

#### 实现的概述

类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

非抽象子类实现接口：

1. 必须重写接口中的所有抽象方法。
2. 继承了接口的默认方法，即可以直接调用，也可以重写。

语法格式：

```java
class 类名 implements 接口名 {
    // 重写接口中的抽象方法【必须】
    // 重写接口中的默认方法【可选】
}
```

#### 抽象方法的使用

定义的接口：

```java
// 定义的接口
public interface LiveAble {
    // 定义的抽象方法
    // 接口中的抽象方法public abstract是可以省略不写的
    public abstract void eat();
    public abstract void sleep();
}
```

实现接口的实现类：

```java
public class Cat implements LiveAble {
    
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    @Override
    public void sleep() {
        System.out.println("猫睡觉");
    }
}
```

#### 默认方法的使用

接口中的默认方法可以继承，可以重写，二选择一，但是只能通过实现类的对象来调用。

继承默认方法示例：

::: code-group
```java [LiveAble]
public interface LiveAble {
    public default void fly() {
        System.out.println("天上飞");
    }
}
```

```java [Bird]
public class Bird implements LiveAble {
    // 继承接口中的默认方法，什么都不写，直接调用
}
```

```java [Demo01Test]
public class Demo01Test {
    public static void main(String[] args) {
        // 创建子类对象
        Bird b = new Bird();
        // 调用默认方法
        b.fly();
    }
}
```
:::

输出结果：

```
天上飞
```

重写默认方法示例：

::: code-group
```java [LiveAble]
public interface LiveAble {
    public default void fly() {
        System.out.println("天上飞");
    }
}
```

```java [Bird]
public class Bird implements LiveAble {
    // 重写接口中的默认方法
    @Override
    public void fly() {
        System.out.println("极速的飞");
    }
}
```

```java [Demo01Test]
public class Demo01Test {
    public static void main(String[] args) {
        // 创建子类对象
        Bird b = new Bird();
        // 调用默认方法
        b.fly();
    }
}
```
:::

输出结果：

```
极速的飞
```

#### 静态方法的使用

静态与 `.class` 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用。

示例：

::: code-group
```java [LiveAble]
public interface LiveAble {

    // 接口静态方法
    public static void run() {
        System.out.println("跑...");
    }
}
```

```java [Animal]
public class Animal implements LiveAble {
    // 无法重写静态方法
}
```

```java [Demo02Test]
public class Demo02Test {
    public static void main(String[] args) {
        // Animal.run(); // 错误❌ 无法继承方法，也无法调用
        // 调用接口中的静态方法
        LiveAble.run();
    }
}
```
:::

输出结果：

```text
跑...
```

#### 私有方法的使用

- 私有方法：只有默认方法可以调用。
- 私有静态方法：默认方法和静态方法可以调用。

如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

示例：

```java
public interface LiveAble {

    // 默认方法
    default void func1() {
        func2(); // 调用接口私有方法
        func3();
    }

    // 接口私有方法
    private void func2() {
        System.out.println("func2 run...");
    }

    // 接口私有方法
    private void func3() {
        System.out.println("func3 run...");
    }
}
```

### 接口多实现

在继承中，一个类只能继承一个父类，对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现，并且，一个类能继承一个父类，同时实现多个接口。

语法格式：

```java
class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【不重名时可选】
}
```

#### 抽象方法

接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。

示例：

::: code-group
```java [接口A]
public interface A {
    public abstract void show1();
    public abstract void show2();
}
```

```java [接口B]
public interface B {
    public abstract void show3();
    public abstract void show4();
}
```

```java [实现类]
public class C implements A, B {
    @Override
    public void show1() {
        System.out.println("重写接口A的show1()方法");
    }

    @Override
    public void show2() {
        System.out.println("重写接口A的show2()方法");
    }

    @Override
    public void show3() {
        System.out.println("重写接口B的show3()方法");
    }

    @Override
    public void show4() {
        System.out.println("重写接口B的show4()方法");
    }
}
```
:::

#### 默认方法

接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。

示例：

::: code-group
```java [接口A]
public interface A {
    public default void methodA() {
        System.out.println("interface A methodA()");
    }

    public default void method() {
        System.out.println("interface A method()");
    }
}
```

```java [接口B]
public interface B {
    public default void methodB() {
        System.out.println("interface B methodB()");
    }

    public default void method() {
        System.out.println("interface B method()");
    }
}
```

```java [实现类C]
public class C implements A, B {

    @Override
    public void method() {
        System.out.println("C class Override method()");
    }
}
```
:::

#### 静态方法

接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

示例：

::: code-group
```java [接口1]
public interface Printer {
    static void print(String msg) {
        System.out.println("Printer: " + msg.toUpperCase());
    }
}
```

```java [接口2]
public interface Logger {
    static void print(String msg) {
        System.out.println("Logger: [" + msg + "]");
    }
}
```

```java [接口3]
public interface Debugger {
    static void print(String msg) {
        System.out.println("Debugger: >>> " + msg + " <<<");
    }
}
```

```java [实现类]
public class MultiTool implements Printer, Logger, Debugger {

    public void test() {
        // 必须用 接口名.方法名() 调用，清晰无歧义
        Printer.print("hello");     // Printer: HELLO
        Logger.print("启动成功");   // Logger: [启动成功]
        Debugger.print("debug mode"); // Debugger: >>> debug mode <<<
    }
}
```

```java [测试代码]
public class TestMain {
    public static void main(String[] args) {
        MultiTool tool = new MultiTool();
        tool.test();

        System.out.println("---");

        // 也可以直接通过接口名调用
        Printer.print("直接调用");
        Logger.print("日志记录");
        Debugger.print("断点信息");
    }
}
```
:::

#### 优先级问题

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。

示例：

::: code-group
```java [定义接口]
public interface A {

    public default void methodA() {
        System.out.println("AAA");
    }
}
```

```java [定义父类]
public class D {

    public void methodA() {
        System.out.println("DDD");
    }
}
```

```java [定义子类]
public class C extends D implements A {
    // 未重写methodA方法
}
```

```java [测试代码]
public class TestMain {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
```
:::

输出结果：

```text
DDD
```

#### 接口多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。

示例：

```java
// 第一个接口：定义飞行能力
public interface Flyable {
    void fly();
    default void land() {
        System.out.println("正在降落...");
    }
}

// 第二个接口：定义游泳能力
public interface Swimmable {
    void swim();
}

// 第三个接口：继承 Flyable 和 Swimmable，实现多继承
public interface Amphibious extends Flyable, Swimmable {
    // 可以添加新的抽象方法
    void dive();
}

// 实现类：实现 Amphibious 接口，间接实现多继承
public class Duck implements Amphibious {
    
    @Override
    public void fly() {
        System.out.println("鸭子在飞翔");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在游泳");
    }
    
    @Override
    public void dive() {
        System.out.println("鸭子潜入水下");
    }
}

// 测试类
public class TestMain {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly();   // 输出: 鸭子在飞翔
        duck.swim();  // 输出: 鸭子在游泳
        duck.dive();  // 输出: 鸭子潜入水下
        duck.land();  // 输出: 正在降落... (继承自 Flyable 的默认方法)
    }
}
``` 

## 多态

### 概述

Java多态是指同一个方法在不同对象上可以有不同的行为，即允许使用父类类型的引用指向子类对象，并在运行时根据实际对象的类型来调用相应的方法。这是Java面向对象三大特性之一，其核心在于 “向上转型”和“方法重写”，从而实现了代码的灵活性和可扩展性。

多态：是指同一行为，具有多种不同的表现形式。

多态的前提：

- 继承或者实现【二选一】
- 方法的重写【意义体现：不重写，无意义】
- 父类引用指向子类对象【格式表现】

### 多态的体现

多态体现的语法格式：

```java
父类类型 变量名 = new 子类对象;
变量名.方法名();
```

> 父类类型：指的是子类继承的父类类型，或者实现的父接口类型。

示例：

```java
Animal animal = new Cat();
animal.run();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后的方法。

示例：

::: code-group
```java [定义父类]
// 抽象类
public abstract class Animal {
    public abstract void eat();
}
```

```java [定义子类]
public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

```java [定义子类]
public class Dog extends Animal {

    @Override
    public void eat() {
        System.out.println("吃骨头");
    }
}
```

```java [测试类]
public class TestMain {
    public static void main(String[] args) {
        // 多态的形式创建对象
        Animal a1 = new Cat();
        // 调用的是 Cat 的 eat() 方法
        a1.eat();  // 输出：吃鱼

        // 多态的形式创建对象
        Animal a2 = new Dog();
        // 调用的是 Dog 的 eat() 方法
        a2.eat();  // 输出：吃骨头
    }
}
```
:::

### 多态的好处

实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。

示例：

::: code-group
```java [定义父类]
public abstract class Animal {
    // 抽象方法
    public abstract void eat();
}
```

```java [定义子类]
public class Cat extends Animal {

    // 重写父类的抽象方法
    @Override
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

```java [定义子类]
public class Dog extends Animal {

    // 重写父类的抽象方法
    @Override
    public void eat() {
        System.out.println("吃骨头");
    }
}
```

```java [测试类]
public class TestMain {
    public static void main(String[] args) {
        // 创建对象
        Cat cat = new Cat();
        Dog dog = new Dog();

        // 调用showCatEat
        showCatEat(cat);
        // 调用showDogEat
        showDogEat(dog);
        
        /**
         * 以上两个方法，均可以被showAnimalEat(Animal a)方法所替代
         * 而且执行效果一致
         */
        showAnimalEat(cat);
        showAnimalEat(dog);
    }

    public static void showCatEat(Cat c) {
        c.eat();
    }

    public static void showDogEat(Dog d) {
        d.eat();
    }

    public static void showAnimalEat(Animal a) {
        a.eat();
    }
}
```
:::

示例说明：

- 由于多态特性的支持 `showAnimalEat()` 方法的Animal类型，是 `Cat` 和 `Dog` 的父类类型，父类类型接收子类对象，当然可以把 `Cat` 对象和 `Dog` 对象，传递给方法。
- 当 `eat()` 方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与 `showCatEat()`、`showDogEat()` 方法一致，所以 `showAnimalEat()` 完全可以替代以上两方法。
- 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写 `showXxxEat()` 方法了，直接使用 `showAnimalEat()` 都可以完成。

### 多态的两种形式

| 形式 | 说明 | 示例 |
| :-- | :-- | :-- |
| 编译时多态（静态多态） | 方法重载（Overloading） | `add(int a, int b)` 和 `add(double a, double b)` |
| 运行时多态（动态多态） | 方法重写（Overriding） + 继承 + 向上转型 | 父类引用调用子类重写的方法 |

> Java 中真正意义的多态指的是运行时多态（基于方法重写）。

### 运行时多态的三个必要条件

要实现运行时多态，必须同时满足以下三个条件：

1. 继承关系：子类继承父类（或者实现接口）
2. 方法重写：子类重写父类的方法（@Override）
3. 向上转型：父类引用指向子类对象

示例：

```java
class Animal {
    public void makeSound() {
        System.out.println("动物叫声");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪！");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵！");
    }
}

// 使用多态
public class TestMain {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // 向上转型
        Animal a2 = new Cat();

        a1.makeSound();  // 输出：汪汪！
        a2.makeSound();  // 输出：喵喵！
    }
}
```

### 多态的引用类型转换

多态的转型分为向上转型与向下转型两种。

- **向上转型**：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。

当父类引用指向一个子类对象时，便是向上转型。

语法格式：

```java
父类类型 变量名 = new 子类类型();
```

示例：

```java
// 1. 父类
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音...");
    }
}

// 2. 子类1：狗
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪汪！");
    }

    // 狗独有方法
    public void fetch() {
        System.out.println("狗狗去叼球！");
    }
}

// 3. 子类2：猫
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵喵～");
    }

    // 猫独有方法
    public void climb() {
        System.out.println("猫猫在爬树！");
    }
}

// 4. 测试类
public class TestMain {
    public static void main(String[] args) {

        // 向上转型 1：父类引用指向子类对象
        Animal animal1 = new Dog();   // 向上转型
        Animal animal2 = new Cat();   // 向上转型

        // 调用重写的方法 → 多态行为
        animal1.makeSound();  // 输出：汪汪汪！
        animal2.makeSound();  // 输出：喵喵喵～

        System.out.println("-------------------");

        // 放入数组统一管理（多态的典型应用）
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[2] = new Animal();

        for (Animal a : animals) {
            a.makeSound();  // 自动调用对应子类的实现
        }

        System.out.println("-------------------");

        // 注意：向上转型后，不能直接调用子类特有方法
        // animal1.fetch();  // 编译错误！Animal 类型没有 fetch()
    }
}
```

输出结果：

```text
汪汪汪！
喵喵喵～
-------------------
汪汪汪！
喵喵喵～
动物发出声音...
-------------------
```

- **向下转型**：父类类型向子类类型向下转换的过程，这个过程是强制的。

一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

语法格式：

```java
子类类型 变量名 = (子类类型) 父类变量名;
```

示例：

```java
public class TestMain {
    public static void main(String[] args) {
        // 向上转型：父类引用指向子类对象
        Animal animal1 = new Dog("小黑");
        Animal animal2 = new Cat("小白");

        // 多态调用重写方法（正常）
        animal1.makeSound();  // 小黑：汪汪汪！
        animal2.makeSound();  // 小白：喵喵喵～

        System.out.println("===================");

        // 错误！不能直接调用子类特有方法
        // animal1.fetchBall();  // 编译错误！Animal 没有这个方法

        // 正确做法：先用 instanceof 判断，再向下转型
        if (animal1 instanceof Dog) {
            Dog dog = (Dog) animal1;  // 向下转型
            dog.fetchBall();          // 现在可以调用
            dog.wagTail();
        }

        if (animal2 instanceof Cat) {
            Cat cat = (Cat) animal2;  // 向下转型
            cat.climbTree();
            cat.sleep();
        }

        System.out.println("===================");

        // 实际应用：遍历动物园，特殊照顾每种动物
        Animal[] zoo = {
                new Dog("大黄"), new Cat("花花"), new Dog("豆豆")
        };

        for (Animal a : zoo) {
            a.makeSound();  // 多态调用

            // 根据实际类型执行特殊行为
            if (a instanceof Dog) {
                Dog d = (Dog) a;
                d.fetchBall();
            } else if (a instanceof Cat) {
                Cat c = (Cat) a;
                c.climbTree();
            }
        }
    }
}

// 1. 父类
abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    // 所有动物都会叫
    public void makeSound() {
        System.out.println(name + " 发出声音...");
    }
}

// 2. 子类：狗
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + "：汪汪汪！");
    }

    // 狗特有方法
    public void fetchBall() {
        System.out.println(name + " 去叼球啦！");
    }

    public void wagTail() {
        System.out.println(name + " 开心地摇尾巴～");
    }
}

// 3. 子类：猫
class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + "：喵喵喵～");
    }

    // 猫特有方法
    public void climbTree() {
        System.out.println(name + " 爬到树上去了！");
    }

    public void sleep() {
        System.out.println(name + " 正在懒洋洋地睡觉...");
    }
}
```

输出结果：

```text
小黑：汪汪汪！
小白：喵喵喵～
===================
小黑 去叼球啦！
小黑 开心地摇尾巴～
小白 爬到树上去了！
小白 正在懒洋洋地睡觉...
===================
大黄：汪汪汪！
大黄 去叼球啦！
花花：喵喵喵～
花花 爬到树上去了！
豆豆：汪汪汪！
豆豆 去叼球啦！
```

### 为什么要转型

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。

示例：

```java
public class TestMain {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // a.catchMouse(); // 调用不了子类的catchMouse()方法

        // 向下转型
        Cat c = (Cat) a;
        c.catchMouse();
    }
}

// 抽象类
abstract class Animal {
    abstract void eat();
}

// 子类
class Cat extends Animal {

    @Override
    void eat() {
        System.out.println("吃鱼");
    }

    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}

// 子类
class Dog extends Animal {

    @Override
    void eat() {
        System.out.println("吃骨头");
    }

    public void watchHouse() {
        System.out.println("看家");
    }
}
```

### 转型的异常

转型的过程中，一不小心就会遇到这样的问题，请看如下代码：

```java
public class TestMain {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // a.catchMouse(); // 调用不了子类的catchMouse()方法

        // 向下转型
        Dog d = (Dog) a;
        d.watchHouse(); // 调用的是 Dog 的 watchHouse() 方法【运行报错】ClassCastException 异常
    }
}

// 抽象类
abstract class Animal {
    abstract void eat();
}

// 子类
class Cat extends Animal {

    @Override
    void eat() {
        System.out.println("吃鱼");
    }

    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}

// 子类
class Dog extends Animal {

    @Override
    void eat() {
        System.out.println("吃骨头");
    }

    public void watchHouse() {
        System.out.println("看家");
    }
}
```

这段代码可以通过编译，但是运行时，却报出了 `ClassCastException`，类型转换异常！这是因为，明明创建了 `Cat` 类型对象，运行时，当然不能转换成 `Dog` 对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。

为了避免 `ClassCastException` 的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：

```java
变量名 instanceof 数据类型
```

示例：

```java
public class TestMain {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // a.catchMouse(); // 调用不了子类的catchMouse()方法

        // 向下转型
        if (a instanceof Cat) {
            Cat c = (Cat) a;
            c.catchMouse(); // 调用的是 Cat 的 catchMouse() 方法
        } else if (a instanceof Dog) {
            Dog d = (Dog) a;
            d.watchHouse(); // 调用的是 Dog 的 watchHouse() 方法
        }
    }
}

// 抽象类
abstract class Animal {
    abstract void eat();
}

// 子类
class Cat extends Animal {

    @Override
    void eat() {
        System.out.println("吃鱼");
    }

    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}

// 子类
class Dog extends Animal {

    @Override
    void eat() {
        System.out.println("吃骨头");
    }

    public void watchHouse() {
        System.out.println("看家");
    }
}
```

## final 关键字

### 概述

`final` 关键字是一个修饰符，可以用来修饰类、方法、变量（包括局部变量、成员变量、静态变量）以及方法参数。

### 使用方式

#### 修饰类

语法格式：

```java
访问修饰符 final class 类名 {
    // 该类的代码逻辑
}
```

查询API发现像 `public final class String`、`public final class Math`、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。

#### 修饰方法

语法格式：

```java
访问修饰符 final 返回值类型 方法名(参数列表) {
    // 该方法的代码逻辑
}
```

重写被 `final` 修饰的方法，编译时会报错。

#### 修饰变量

基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。

示例：

```java
public class FinalDemo01 {
    public static void main(String[] args) {
        // 声明变量，使用 final 修饰
        final int a;
        // 第一次赋值
        a = 10;
        // 第二次赋值
        a = 20; // 编译报错，不能重新赋值
        
        // 声明变量，直接赋值，使用 final 修饰
        final int b = 10;
        // 第二次赋值
        b = 30; // 编译报错，不能重新赋值
    }
}
```

思考，如下两种写法，哪种可以通过编译？

写法1：

```java
final int c = 0;
for (int i = 0; i < 10; i++) {
    c = i;
    System.out.println(c);
}
```

写法2：

```java
for (int i = 0; i < 10; i++) {
    final int c = i;
    System.out.println(c);
}
```

根据 `final` 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。

引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改。

示例：

```java
public class FinalDemo02 {
    public static void main(String[] args) {
        // 创建 User 对象
        final User u = new User();
        // 创建 另一个 User对象
        u = new User(); // 报错，指向了新的对象，地址值改变。
        
        // 调用setName方法
        u.setName("张三"); // 可以修改
    }
}
```

成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：

- 显示初始化

```java
public class User {
    final String USERNAME = "张三";
    private int age;
}
```

- 构造方法初始化

```java
public class User {
    final String USERNAME;
    private int age;
    
    public User(String username, int age) {
        this.USERNAME = username;
        this.age = age;
    }
}
```

> 被final修饰的常量名称，一般都有书写规范，所有字母都大写。

## 权限修饰符

### 概述

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。

| 修饰符 | 说明 |
| :---: | :--- |
| public | 公开的，任何人都可以访问 |
| private | 私有的，只有自己可以访问 |
| protected | 受保护的，子类可以访问 |
| default | 默认的，同一个包下的类可以访问 |

### 不同权限的访问能力

| | public | private | protected | default |
| :-- | :-- | :-- | :-- | :-- |
| 同一个类中 | ✅ | ✅ | ✅ | ✅ |
| 同一个包中（子类与无关类） | ✅ | ✅ | ✅ |  |
| 不同包的子类 | ✅ | ✅ |  |  |
| 不同包中的无关类 | ✅ |  |  |  |

::: tip 提示
文档正在更新中...
:::

## 参考资料

- [菜鸟教程](https://www.runoob.com)
- [C语言中文网-Java学习教程](https://c.biancheng.net/java/)