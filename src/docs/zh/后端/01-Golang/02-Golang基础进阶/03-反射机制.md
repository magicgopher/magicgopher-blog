---
title: åå°„æœºåˆ¶
author: MagicGopher
keywords: go, golang, reflection
description: ä»‹ç» Go è¯­è¨€çš„åå°„æœºåˆ¶
editLink: false
---

# åå°„æœºåˆ¶

## ä»€ä¹ˆæ˜¯åå°„ï¼Ÿ

åœ¨è®¡ç®—æœºä¸­ï¼Œåå°„æ˜¯æŒ‡è®¡ç®—æœºç¨‹åºåœ¨è¿è¡Œæ—¶ï¼ˆRun Timeï¼‰å¯ä»¥è®¿é—®ã€æ£€æµ‹å’Œä¿®æ”¹ç¨‹åºæœ¬èº«çš„çŠ¶æ€å’Œè¡Œä¸ºçš„ä¸€ç§èƒ½åŠ›ï¼Œç®€å•çš„æ¥è¯´ï¼Œåå°„å…¶å®å°±æ˜¯ç¨‹åºåœ¨è¿è¡Œçš„æ—¶å€™ï¼Œèƒ½å¤Ÿ â€œè§‚å¯ŸğŸ‘€â€ å¹¶ä¸”ä¿®æ”¹è‡ªå·±çš„è¡Œä¸ºã€‚

## reflectåŒ…

`reflect` åŒ…æä¾›äº†è¿è¡Œæ—¶åå°„åŠŸèƒ½ï¼Œå…è®¸ç¨‹åºåœ¨è¿è¡Œæ—¶æ£€æŸ¥å’Œæ“ä½œå˜é‡çš„ç±»å‹ã€å€¼ã€ç»“æ„ä½“å­—æ®µç­‰ã€‚å®ƒæ˜¯ Go è¯­è¨€å®ç°åŠ¨æ€è¡Œä¸ºçš„é‡è¦å·¥å…·ï¼Œå¸¸ç”¨äºåºåˆ—åŒ–ã€ååºåˆ—åŒ–ã€ORM æ¡†æ¶ç­‰åœºæ™¯ã€‚

## Type & Value

`reflect.TypeOf()` å‡½æ•°ç”¨äºè·å–ç±»å‹ä¿¡æ¯ï¼Œè¿”å› `Type` ç±»å‹ï¼›

```go
func TypeOf(i any) Type {...}
```

`reflect.ValueOf()` å‡½æ•°ç”¨äºè·å–å€¼ä¿¡æ¯ï¼Œè¿”å› `Value` ç±»å‹ã€‚

```go
func ValueOf(i any) Value {...}
```

é€šè¿‡ `reflect.TypeOf()` å’Œ `reflect.ValueOf()` å‡½æ•°ï¼Œç»è¿‡ä¸­é—´å˜é‡ `any` æŠŠä¸€ä¸ªæ™®é€šçš„å˜é‡è½¬æ¢ä¸ºåå°„åŒ…ä¸­çš„ç±»å‹ `Type` å’Œ `Value` è¿™ä¸¤ä¸ªç±»å‹çš„å˜é‡å®ä¾‹ï¼Œç„¶åå†ç”¨ `reflect` åŒ…ä¸­çš„æ–¹æ³•è¿›è¡Œæ“ä½œã€‚

```mermaid
flowchart LR
    A[Goå˜é‡] --> B[any]
    B[any] --> C[åå°„å¯¹è±¡]
```

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {

	// åå°„æ“ä½œï¼šé€šè¿‡åå°„ï¼Œå¯ä»¥è·å–ä¸€ä¸ªæ¥å£ç±»å‹å˜é‡çš„ç±»å‹å’Œæ•°å€¼ï¼ˆä¹Ÿå°±æ˜¯reflect.Typeå’Œreflect.Valueï¼‰
	var x = 1.2345

	fmt.Println("type:", reflect.TypeOf(x))   // type: float64
	fmt.Println("value:", reflect.ValueOf(x)) // value: 1.2345

	fmt.Println("==========")
	// æ ¹æ®åå°„çš„å€¼ï¼Œæ¥è·å–å¯¹åº”çš„ç±»å‹å’Œæ•°å€¼
	v := reflect.ValueOf(x)
	fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
	fmt.Println("type:", v.Type())
	fmt.Println("value:", v.Float())
}
```

è¾“å‡ºç»“æœï¼š

```text
type: float64
value: 1.2345
==========
kind is float64: true
type: float64
value: 1.2345
```

ç¤ºä¾‹è¯´æ˜ï¼š
- `reflect.TypeOf`ï¼šç›´æ¥ç»™åˆ°äº†æˆ‘ä»¬æƒ³è¦çš„typeç±»å‹ï¼Œå¦‚float64ã€intã€å„ç§pointerã€struct ç­‰ç­‰çœŸå®çš„ç±»å‹ã€‚
- `reflect.ValueOf`ï¼š1. ç›´æ¥ç»™åˆ°äº†æˆ‘ä»¬æƒ³è¦çš„å…·ä½“çš„å€¼ï¼Œå¦‚1.2345è¿™ä¸ªå…·ä½“æ•°å€¼ï¼Œæˆ–è€…ç±»ä¼¼&{1 "Allen.Wu" 25} è¿™æ ·çš„ç»“æ„ä½“structçš„å€¼ã€‚
- ä¹Ÿå°±æ˜¯è¯´æ˜åå°„å¯ä»¥å°†â€œæ¥å£ç±»å‹å˜é‡â€è½¬æ¢ä¸ºâ€œåå°„ç±»å‹å¯¹è±¡â€ï¼Œåå°„ç±»å‹æŒ‡çš„æ˜¯reflect.Typeå’Œreflect.Valueè¿™ä¸¤ç§ã€‚

Type å’Œ Value éƒ½åŒ…å«äº†å¤§é‡çš„æ–¹æ³•ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªæœ‰ç”¨çš„æ–¹æ³•åº”è¯¥æ˜¯ Kindï¼Œè¿™ä¸ªæ–¹æ³•è¿”å›è¯¥ç±»å‹çš„å…·ä½“ä¿¡æ¯ï¼šUintã€Float64 ç­‰ã€‚Value ç±»å‹è¿˜åŒ…å«äº†ä¸€ç³»åˆ—ç±»å‹æ–¹æ³•ï¼Œæ¯”å¦‚ Int()ï¼Œç”¨äºè¿”å›å¯¹åº”çš„å€¼ã€‚ä»¥ä¸‹æ˜¯Kindçš„ç§ç±»ã€‚

```go
// A Kind represents the specific kind of type that a [Type] represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Pointer
	Slice
	String
	Struct
	UnsafePointer
)
```

## åå°„çš„è§„åˆ™

å…¶å®åå°„çš„æ“ä½œæ­¥éª¤éå¸¸çš„ç®€å•ï¼Œå°±æ˜¯é€šè¿‡å®ä½“å¯¹è±¡è·å–åå°„å¯¹è±¡ï¼ˆValueã€Typeï¼‰ï¼Œç„¶åæ“ä½œç›¸åº”çš„æ–¹æ³•å³å¯ã€‚

ä¸‹å›¾æè¿°äº†å®ä¾‹ã€Valueã€Type ä¸‰è€…ä¹‹é—´çš„è½¬æ¢å…³ç³»ï¼š

```mermaid
flowchart LR
    A[Type] <--> B[å®ä¾‹]
    B[å®ä¾‹] <--> C[Value]
    C[Value] <--> A[Type]
```

åå°„ API çš„åˆ†ç±»æ€»ç»“å¦‚ä¸‹ï¼š

**ï¼ˆ1ï¼‰ä»å®ä¾‹åˆ° Value**

é€šè¿‡å®ä¾‹è·å– Value å¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨ reflect.ValueOf() å‡½æ•°ã€‚ä¾‹å¦‚ï¼š

```go
func ValueOf(i interface{}) {...}
```

**ï¼ˆ2ï¼‰ä»å®ä¾‹åˆ° Type**

é€šè¿‡å®ä¾‹è·å–åå°„å¯¹è±¡çš„ Typeï¼Œç›´æ¥ä½¿ç”¨ reflect.TypeOf() å‡½æ•°ã€‚ä¾‹å¦‚ï¼š

```go
func TypeOf(i interface{}) Type {...}
```

**ï¼ˆ3ï¼‰ä» Type åˆ° Value**

Type é‡Œé¢åªæœ‰ç±»å‹ä¿¡æ¯ï¼Œæ‰€ä»¥ç›´æ¥ä»ä¸€ä¸ª Type æ¥å£å˜é‡é‡Œé¢æ˜¯æ— æ³•è·å¾—å®ä¾‹çš„ Value çš„ï¼Œä½†å¯ä»¥é€šè¿‡è¯¥ Type æ„å»ºä¸€ä¸ªæ–°å®ä¾‹çš„ Valueã€‚reflect åŒ…æä¾›äº†ä¸¤ç§æ–¹æ³•ï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
//New è¿”å›çš„æ˜¯ä¸€ä¸ª Valueï¼Œè¯¥ Value çš„ type ä¸º PtrTo(typ)ï¼Œå³ Value çš„ Type æ˜¯æŒ‡å®š typ çš„æŒ‡é’ˆç±»å‹
func New(typ Type) Value
//Zero è¿”å›çš„æ˜¯ä¸€ä¸ª typ ç±»å‹çš„é›¶å€¼ï¼Œæ³¨æ„è¿”å›çš„ Value ä¸èƒ½å¯»å€ä¹Ÿä¸å¯æ”¹å˜
func Zero(typ Type) Value
```

å¦‚æœçŸ¥é“ä¸€ä¸ªç±»å‹å€¼çš„åº•å±‚å­˜æ”¾åœ°å€ï¼Œåˆ™è¿˜æœ‰ä¸€ä¸ªå‡½æ•°æ˜¯å¯ä»¥ä¾æ® type å’Œè¯¥åœ°å€å€¼æ¢å¤å‡º Value çš„ã€‚ä¾‹å¦‚ï¼š

```go
func NewAt(typ Type, p unsafe.Pointer) Value
```

**ï¼ˆ4ï¼‰ä» Value åˆ° Type**

ä»åå°„å¯¹è±¡ Value åˆ° Type å¯ä»¥ç›´æ¥è°ƒç”¨ Value çš„æ–¹æ³•ï¼Œå› ä¸º Value å†…éƒ¨å­˜æ”¾ç€åˆ° Type ç±»å‹çš„æŒ‡é’ˆã€‚ä¾‹å¦‚ï¼š

```go
func (v Value) Type() Type
```

**ï¼ˆ5ï¼‰ä» Valueåˆ°å®ä¾‹**

Value æœ¬èº«å°±åŒ…å«ç±»å‹å’Œå€¼ä¿¡æ¯ï¼Œreflect æä¾›äº†ä¸°å¯Œçš„æ–¹æ³•æ¥å®ç°ä» Value åˆ°å®ä¾‹çš„è½¬æ¢ã€‚ä¾‹å¦‚ï¼š

```go
//è¯¥æ–¹æ³•æœ€é€šç”¨ï¼Œç”¨æ¥å°† Value è½¬æ¢ä¸ºç©ºæ¥å£ï¼Œè¯¥ç©ºæ¥å£å†…éƒ¨å­˜æ”¾å…·ä½“ç±»å‹å®ä¾‹
//å¯ä»¥ä½¿ç”¨æ¥å£ç±»å‹æŸ¥è¯¢å»è¿˜åŸä¸ºå…·ä½“çš„ç±»å‹
func (v Value) Interface() ï¼ˆi interface{})

//Value è‡ªèº«ä¹Ÿæä¾›ä¸°å¯Œçš„æ–¹æ³•ï¼Œç›´æ¥å°† Value è½¬æ¢ä¸ºç®€å•ç±»å‹å®ä¾‹ï¼Œå¦‚æœç±»å‹ä¸åŒ¹é…ï¼Œåˆ™ç›´æ¥å¼•èµ· panic
func (v Value) Bool () bool
func (v Value) Float() float64
func (v Value) Int() int64
func (v Value) Uint() uint64
```

**ï¼ˆ6ï¼‰ä» Value çš„æŒ‡é’ˆåˆ°å€¼**

ä»ä¸€ä¸ªæŒ‡é’ˆç±»å‹çš„ Value è·å¾—å€¼ç±»å‹ Value æœ‰ä¸¤ç§æ–¹æ³•ï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
//å¦‚æœ v ç±»å‹æ˜¯æ¥å£ï¼Œåˆ™ Elem() è¿”å›æ¥å£ç»‘å®šçš„å®ä¾‹çš„ Valueï¼Œå¦‚æœ v ç±»å‹æ˜¯æŒ‡é’ˆï¼Œåˆ™è¿”å›æŒ‡é’ˆå€¼çš„ Valueï¼Œå¦åˆ™å¼•èµ· panic
func (v Value) Elem() Value
//å¦‚æœ v æ˜¯æŒ‡é’ˆï¼Œåˆ™è¿”å›æŒ‡é’ˆå€¼çš„ Valueï¼Œå¦åˆ™è¿”å› v è‡ªèº«ï¼Œè¯¥å‡½æ•°ä¸ä¼šå¼•èµ· panic
func Indirect(v Value) Value
```

**ï¼ˆ7ï¼‰Type æŒ‡é’ˆå’Œå€¼çš„ç›¸äº’è½¬æ¢**

æŒ‡é’ˆç±»å‹ Type åˆ°å€¼ç±»å‹ Typeã€‚ä¾‹å¦‚ï¼š

```go
//t å¿…é¡»æ˜¯ Arrayã€Chanã€Mapã€Ptrã€Sliceï¼Œå¦åˆ™ä¼šå¼•èµ· panic
//Elem è¿”å›çš„æ˜¯å…¶å†…éƒ¨å…ƒç´ çš„ Type
t.Elem() Type
```

å€¼ç±»å‹ Type åˆ°æŒ‡é’ˆç±»å‹ Typeã€‚ä¾‹å¦‚ï¼š

```go
//PtrTo è¿”å›çš„æ˜¯æŒ‡å‘ t çš„æŒ‡é’ˆå‹ Type
func PtrTo(t Type) Type
```

**ï¼ˆ8ï¼‰Value å€¼çš„å¯ä¿®æ”¹æ€§**

Value å€¼çš„ä¿®æ”¹æ¶‰åŠå¦‚ä¸‹ä¸¤ä¸ªæ–¹æ³•ã€‚

```go
//é€šè¿‡ CanSet åˆ¤æ–­æ˜¯å¦èƒ½ä¿®æ”¹
func (v Value ) CanSet() bool
//é€šè¿‡ Set è¿›è¡Œä¿®æ”¹
func (v Value ) Set(x Value)
```

Value å€¼åœ¨ä»€ä¹ˆæƒ…å†µä¸‹å¯ä»¥ä¿®æ”¹ï¼Ÿæˆ‘ä»¬çŸ¥é“å®ä¾‹å¯¹è±¡ä¼ é€’ç»™æ¥å£çš„æ˜¯ä¸€ä¸ªå®Œå…¨çš„å€¼æ‹·è´ï¼Œå¦‚æœè°ƒç”¨åå°„çš„æ–¹æ³• reflect.ValueOf() ä¼ è¿›å»çš„æ˜¯ä¸€ä¸ªå€¼ç±»å‹å˜é‡ï¼Œ åˆ™è·å¾—çš„ Value å®é™…ä¸Šæ˜¯åŸå¯¹è±¡çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œè¿™ä¸ª Value æ˜¯æ— è®ºå¦‚ä½•ä¹Ÿä¸èƒ½è¢«ä¿®æ”¹çš„ã€‚

**æ ¹æ® Go å®˜æ–¹å…³äºåå°„çš„åšå®¢ï¼Œåå°„æœ‰ä¸‰å¤§å®šå¾‹**ï¼š

1. Reflection goes from interface value to reflection object.
2. Reflection goes from reflection object to interface value.
3. Reflection goes from reflection object to interface value.

**è¯‘æ–‡ï¼š**

1. åå°„å¯ä»¥ä»æ¥å£å€¼å¾—åˆ°åå°„å¯¹è±¡ã€‚
2. åå°„å¯ä»¥ä»åå°„å¯¹è±¡è·å¾—æ¥å£å€¼ã€‚
3. è¦ä¿®æ”¹åå°„å¯¹è±¡ï¼Œè¯¥å€¼å¿…é¡»ä¸ºå¯è®¾ç½®ã€‚

åå°„ä¸‰å¤§å®šå¾‹åšå®¢åœ°å€ï¼š[https://go.dev/blog/laws-of-reflection](https://go.dev/blog/laws-of-reflection)

## åå°„è·å–æ¥å£å˜é‡ä¿¡æ¯

å½“æ‰§è¡Œ reflect.ValueOf(interface) ä¹‹åï¼Œå°±å¾—åˆ°äº†ä¸€ä¸ªç±»å‹ä¸º â€œrelfect.Valueâ€ å˜é‡ï¼Œå¯ä»¥é€šè¿‡å®ƒæœ¬èº«çš„ Interface() æ–¹æ³•è·å¾—æ¥å£å˜é‡çš„çœŸå®å†…å®¹ï¼Œç„¶åå¯ä»¥é€šè¿‡ç±»å‹åˆ¤æ–­è¿›è¡Œè½¬æ¢ï¼Œè½¬æ¢ä¸ºåŸæœ‰çœŸå®ç±»å‹ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯èƒ½æ˜¯å·²çŸ¥åŸæœ‰ç±»å‹ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯æœªçŸ¥åŸæœ‰ç±»å‹ï¼Œå› æ­¤ï¼Œä¸‹é¢åˆ†ä¸¤ç§æƒ…å†µè¿›è¡Œè¯´æ˜ã€‚

**ï¼ˆ1ï¼‰å·²çŸ¥åŸæœ‰ç±»å‹**

å·²çŸ¥ç±»å‹åè½¬æ¢ä¸ºå…¶å¯¹åº”çš„ç±»å‹çš„åšæ³•å¦‚ä¸‹ï¼Œç›´æ¥é€šè¿‡ Interface æ–¹æ³•ç„¶åå¼ºåˆ¶è½¬æ¢ï¼Œå¦‚ä¸‹ï¼š

```go
realValue := value.Interface().(å·²çŸ¥çš„ç±»å‹)
```

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var num = 1.2345678910

	pointer := reflect.ValueOf(&num) // æŒ‡å‘ num çš„æŒ‡é’ˆ
	value := reflect.ValueOf(num)    // num å€¼çš„å‰¯æœ¬

	// å¯ä»¥ç†è§£ä¸ºâ€œå¼ºåˆ¶è½¬æ¢â€ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ—¶å€™ï¼Œè½¬æ¢çš„æ—¶å€™ï¼Œå¦‚æœè½¬æ¢çš„ç±»å‹ä¸å®Œå…¨ç¬¦åˆï¼Œåˆ™ç›´æ¥ panic
	// Golang å¯¹ç±»å‹è¦æ±‚éå¸¸ä¸¥æ ¼ï¼Œç±»å‹ä¸€å®šè¦å®Œå…¨ç¬¦åˆ
	// å¦‚ä¸‹ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯ *float64ï¼Œä¸€ä¸ªæ˜¯ float64ï¼Œå¦‚æœå¼„æ··ï¼Œåˆ™ä¼š panic
	convertPointer := pointer.Interface().(*float64)
	convertValue := value.Interface().(float64)

	fmt.Println(convertPointer) // æŒ‡é’ˆå­˜å‚¨çš„åœ°å€å€¼
	fmt.Println(convertValue)   // å˜é‡å­˜å‚¨çš„æ•°å€¼å‰¯æœ¬
}
```

è¾“å‡ºç»“æœï¼š

```text
0x1400000e0a0
1.234567891
```

ç¤ºä¾‹è¯´æ˜ï¼š

1. è½¬æ¢çš„æ—¶å€™ï¼Œå¦‚æœè½¬æ¢çš„ç±»å‹ä¸å®Œå…¨ç¬¦åˆï¼Œåˆ™ç›´æ¥panicï¼Œç±»å‹è¦æ±‚éå¸¸ä¸¥æ ¼ï¼
2. è½¬æ¢çš„æ—¶å€™ï¼Œè¦åŒºåˆ†æ˜¯æŒ‡é’ˆè¿˜æ˜¯å€¼ã€‚
3. ä¹Ÿå°±æ˜¯è¯´åå°„å¯ä»¥å°†â€œåå°„ç±»å‹å¯¹è±¡â€å†é‡æ–°è½¬æ¢ä¸ºâ€œæ¥å£ç±»å‹å˜é‡â€œã€‚

**ï¼ˆ2ï¼‰æœªçŸ¥åŸæœ‰ç±»å‹**

å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½å¹¶ä¸çŸ¥é“å…¶å…·ä½“ç±»å‹ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ï¼Œè¯¥å¦‚ä½•åšå‘¢ï¼Ÿéœ€è¦æˆ‘ä»¬è¿›è¡Œéå†æ¢æµ‹å…¶ Filed æ¥å¾—çŸ¥ã€‚

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

type Person struct {
	Name string
	Age  uint
	Sex  string
}

func (p Person) Say(msg string) {
	fmt.Println("hello, ", msg)
}

func (p Person) PrintInfo() {
	fmt.Printf("å§“å: %s, å¹´é¾„: %d, æ€§åˆ«: %s\n", p.Name, p.Age, p.Sex)
}

func main() {
	p1 := Person{"Gopher", 18, "æœªçŸ¥"}

	DoFileAndMethod(p1)
}

func DoFileAndMethod(input interface{}) {

	// å…ˆè·å– input çš„ç±»å‹
	getType := reflect.TypeOf(input)
	fmt.Println("get type is:", getType.Name()) // Person
	fmt.Println("get kind is:", getType.Kind()) // struct

	// å†è·å– input çš„å€¼
	getValue := reflect.ValueOf(input)
	fmt.Println("get all Fields is:", getValue) // {Gopher 18 æœªçŸ¥}

	// è·å–å­—æ®µ
	// 1. å…ˆè·å– interface çš„ reflect.Typeï¼Œç„¶åé€šè¿‡ NumField è¿›è¡Œéå†
	// 2. å†é€šè¿‡ reflect.Type çš„ Field è·å–å…¶ Field
	// 3. æœ€åé€šè¿‡ Field çš„ Interface() å¾—åˆ°å¯¹åº”çš„ value
	for i := 0; i < getType.NumField(); i++ {
		field := getType.Field(i)
		value := getValue.Field(i).Interface() //è·å–ç¬¬ i ä¸ªå€¼
		fmt.Printf("å­—æ®µåç§°ï¼š%sï¼Œå­—æ®µç±»å‹ï¼š%sï¼Œå­—æ®µæ•°å€¼ï¼š%v\n", field.Name, field.Type, value)
	}

	// æ“ä½œæ–¹æ³•
	// 1. å…ˆè·å– interface çš„ reflect.Typeï¼Œç„¶åé€šè¿‡ .NumMethod è¿›è¡Œéå†
	// 2. å†é€šè¿‡ reflect.Type çš„ Method è·å–å…¶ Method
	for i := 0; i < getType.NumMethod(); i++ {
		method := getType.Method(i)
		fmt.Printf("æ–¹æ³•åç§°ï¼š%sï¼Œæ–¹æ³•ç±»å‹ï¼š%v\n", method.Name, method.Type)
	}
}
```

è¾“å‡ºç»“æœï¼š

```text
get type is: Person
get kind is: struct
get all Fields is: {Gopher 18 æœªçŸ¥}
å­—æ®µåç§°ï¼šNameï¼Œå­—æ®µç±»å‹ï¼šstringï¼Œå­—æ®µæ•°å€¼ï¼šGopher
å­—æ®µåç§°ï¼šAgeï¼Œå­—æ®µç±»å‹ï¼šuintï¼Œå­—æ®µæ•°å€¼ï¼š18
å­—æ®µåç§°ï¼šSexï¼Œå­—æ®µç±»å‹ï¼šstringï¼Œå­—æ®µæ•°å€¼ï¼šæœªçŸ¥
æ–¹æ³•åç§°ï¼šPrintInfoï¼Œæ–¹æ³•ç±»å‹ï¼šfunc(main.Person)
æ–¹æ³•åç§°ï¼šSayï¼Œæ–¹æ³•ç±»å‹ï¼šfunc(main.Person, string)
```

ç¤ºä¾‹è¯´æ˜ï¼š

é€šè¿‡è¿è¡Œç»“æœå¯ä»¥å¾—çŸ¥è·å–æœªçŸ¥ç±»å‹çš„ interface çš„å…·ä½“å˜é‡åŠå…¶ç±»å‹çš„æ­¥éª¤ä¸ºï¼š

1. å…ˆè·å– interface çš„ reflect.Typeï¼Œç„¶åé€šè¿‡ NumField è¿›è¡Œéå†ã€‚
2. å†é€šè¿‡ reflect.Type çš„ Field è·å–å…¶ Fieldã€‚
3. æœ€åé€šè¿‡ Field çš„ Interface() å¾—åˆ°å¯¹åº”çš„ valueã€‚

é€šè¿‡è¿è¡Œç»“æœå¯ä»¥å¾—çŸ¥è·å–æœªçŸ¥ç±»å‹çš„ interface çš„æ‰€å±æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰çš„æ­¥éª¤ä¸ºï¼š

1. å…ˆè·å– interface çš„ reflect.Typeï¼Œç„¶åé€šè¿‡ NumMethod è¿›è¡Œéå†ã€‚
2. å†åˆ†åˆ«é€šè¿‡ reflect.Type çš„ Method è·å–å¯¹åº”çš„çœŸå®çš„æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰ã€‚
3. æœ€åå¯¹ç»“æœå–å…¶ Name å’Œ Type å¾—çŸ¥å…·ä½“çš„æ–¹æ³•åã€‚
4. ä¹Ÿå°±æ˜¯è¯´åå°„å¯ä»¥å°†â€œåå°„ç±»å‹å¯¹è±¡â€å†é‡æ–°è½¬æ¢ä¸ºâ€œæ¥å£ç±»å‹å˜é‡â€ã€‚
5. struct æˆ–è€… struct çš„åµŒå¥—éƒ½æ˜¯ä¸€æ ·çš„åˆ¤æ–­å¤„ç†æ–¹å¼ã€‚

## åå°„è®¾ç½®å®é™…å˜é‡çš„å€¼

reflect.Value æ˜¯é€šè¿‡ `reflect.ValueOf(X)` è·å¾—çš„ï¼Œ åªæœ‰å½“ X æ˜¯æŒ‡é’ˆçš„æ—¶å€™ï¼Œæ‰å¯ä»¥é€šè¿‡ reflec.Value ä¿®æ”¹å®é™…å˜é‡ X çš„å€¼ï¼Œå³ï¼šè¦ä¿®æ”¹åå°„ç±»å‹çš„å¯¹è±¡å°±ä¸€å®šè¦ä¿è¯å…¶å€¼æ˜¯ â€œaddressableâ€ çš„ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼šè¦æƒ³ä¿®æ”¹ä¸€ä¸ªå˜é‡çš„å€¼ï¼Œé‚£ä¹ˆå¿…é¡»é€šè¿‡è¯¥å˜é‡çš„æŒ‡é’ˆåœ°å€ã€‚

é€šè¿‡ `refPtrVal := reflect.Valueof( &var )` çš„æ–¹å¼è·å–æŒ‡é’ˆç±»å‹ï¼Œç„¶åä½¿ç”¨ `refPtrVal.Elem( ).Set(ä¸€ä¸ªæ–°çš„ reflect.Value)` æ¥è¿›è¡Œæ›´æ”¹ï¼Œä¼ é€’ç»™ `Set()` çš„å€¼ä¹Ÿå¿…é¡»æ˜¯ä¸€ä¸ª `reflect.value`ã€‚

```go
// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if v's Kind is not [Interface] or [Pointer].
// It returns the zero Value if v is nil.

// Elem è¿”å›æ¥å£ v åŒ…å«çš„å€¼æˆ–è€… v æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡
// å¦‚æœ v çš„ç±»å‹ä¸æ˜¯ æ¥å£ æˆ– Ptrï¼Œå®ƒä¼šæƒŠæ…Œ
// å¦‚æœ v ä¸º nilï¼Œåˆ™è¿”å› 0 å€¼
func (v Value) Elem() Value {...}
```

å¦‚æœä½ çš„å˜é‡æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€mapã€sliceã€channelã€Arrayã€‚é‚£ä¹ˆä½ å¯ä»¥ä½¿ç”¨ reflect.Typeof(v).Elem() æ¥ç¡®å®šåŒ…å«çš„ç±»å‹ã€‚

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var num = 1.23456
	fmt.Println("numçš„å€¼:", num)

	// éœ€è¦æ“ä½œæŒ‡é’ˆ
	// é€šè¿‡ reflect.ValueOf è·å– num ä¸­çš„ reflect.Valueï¼Œæ³¨æ„ï¼Œå‚æ•°å¿…é¡»æ˜¯æŒ‡é’ˆæ‰èƒ½ä¿®æ”¹å…¶å€¼
	numPointer := reflect.ValueOf(&num)
	elem := numPointer.Elem()
	fmt.Println("ç±»å‹:", elem.Type())       // float64
	fmt.Println("æ˜¯å¦å¯ä»¥ä¿®æ”¹:", elem.CanSet()) // true

	// é‡æ–°èµ‹å€¼
	elem.SetFloat(9.87654)
	fmt.Println("numçš„æ–°å€¼:", num)

	// å¦‚æœreflect.ValueOfçš„å‚æ•°ä¸æ˜¯æŒ‡é’ˆï¼Œä¼šå¦‚ä½•ï¼Ÿ

	// å‚è¯•ç›´æ¥ä¿®æ”¹
	//value := reflect.ValueOf(num)
	//value.SetFloat(4.5678) // panic: reflect: reflect.Value.SetFloat using unaddressable value
	//fmt.Println(value.CanSet()) // false

	//pointer := reflect.ValueOf(num)
	//elem := pointer.Elem() // å¦‚æœéæŒ‡é’ˆï¼Œè¿™é‡Œç›´æ¥panicï¼Œâ€œpanic: reflect: call of reflect.Value.Elem on float64 Valueâ€
}
```

è¾“å‡ºç»“æœï¼š

```text
umçš„å€¼: 1.23456
ç±»å‹: float64
æ˜¯å¦å¯ä»¥ä¿®æ”¹: true
numçš„æ–°å€¼: 9.87654
```

ç¤ºä¾‹è¯´æ˜ï¼š

1. éœ€è¦ä¼ å…¥çš„å‚æ•°æ˜¯* float64è¿™ä¸ªæŒ‡é’ˆï¼Œç„¶åå¯ä»¥é€šè¿‡pointer.Elem()å»è·å–æ‰€æŒ‡å‘çš„Valueï¼Œ**æ³¨æ„ä¸€å®šè¦æ˜¯æŒ‡é’ˆ**ã€‚
2. å¦‚æœä¼ å…¥çš„å‚æ•°ä¸æ˜¯æŒ‡é’ˆï¼Œè€Œæ˜¯å˜é‡ï¼Œé‚£ä¹ˆ
   - é€šè¿‡Elemè·å–åŸå§‹å€¼å¯¹åº”çš„å¯¹è±¡åˆ™ç›´æ¥panic
   - é€šè¿‡CanSetæ–¹æ³•æŸ¥è¯¢æ˜¯å¦å¯ä»¥è®¾ç½®è¿”å›false
3. newValue.CantSet()è¡¨ç¤ºæ˜¯å¦å¯ä»¥é‡æ–°è®¾ç½®å…¶å€¼ï¼Œå¦‚æœè¾“å‡ºçš„æ˜¯trueåˆ™å¯ä¿®æ”¹ï¼Œå¦åˆ™ä¸èƒ½ä¿®æ”¹ï¼Œä¿®æ”¹å®Œä¹‹åå†è¿›è¡Œæ‰“å°å‘ç°çœŸçš„å·²ç»ä¿®æ”¹äº†ã€‚
4. reflect.Value.Elem() è¡¨ç¤ºè·å–åŸå§‹å€¼å¯¹åº”çš„åå°„å¯¹è±¡ï¼Œåªæœ‰åŸå§‹å¯¹è±¡æ‰èƒ½ä¿®æ”¹ï¼Œå½“å‰åå°„å¯¹è±¡æ˜¯ä¸èƒ½ä¿®æ”¹çš„
5. ä¹Ÿå°±æ˜¯è¯´å¦‚æœè¦ä¿®æ”¹åå°„ç±»å‹å¯¹è±¡ï¼Œå…¶å€¼å¿…é¡»æ˜¯â€œaddressableâ€ã€å¯¹åº”çš„è¦ä¼ å…¥çš„æ˜¯æŒ‡é’ˆï¼ŒåŒæ—¶è¦é€šè¿‡Elemæ–¹æ³•è·å–åŸå§‹å€¼å¯¹åº”çš„åå°„å¯¹è±¡ã€‘
6. struct æˆ–è€… struct çš„åµŒå¥—éƒ½æ˜¯ä¸€æ ·çš„åˆ¤æ–­å¤„ç†æ–¹å¼ã€‚

å°è¯•ä¿®æ”¹ç»“æ„ä½“ä¸­çš„å­—æ®µæ•°å€¼ï¼Œç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

type Student struct {
	Name   string
	Age    int
	School string
}

func main() {
	// é€šè¿‡åå°„ï¼Œæ¥æ›´æ”¹å¯¹è±¡çš„å€¼ï¼Œå‰ææ˜¯æ•°å€¼å¯ä»¥è¢«æ›´æ”¹
	s1 := Student{"Gopher", 18, "XXXå°å­¦"}
	fmt.Printf("s1 ç±»å‹ï¼š%T\n", s1)

	p1 := &s1
	fmt.Printf("p1 ç±»å‹ï¼š%T\n", p1)
	fmt.Println("s1.Name:", s1.Name)
	fmt.Println("*p1.Name:", (*p1).Name)

	// ä½¿ç”¨ reflect.ValueOf å–å‡ºå€¼ï¼Œæ³¨æ„ä¼ æŒ‡é’ˆ
	v1 := reflect.ValueOf(&s1)

	if v1.Kind() == reflect.Ptr {
		fmt.Println("v1.Elem æ˜¯å¦å¯ä»¥è®¾ç½®ï¼š", v1.Elem().CanSet())
		v1 = v1.Elem()
	}

	f1 := v1.FieldByName("Name")
	f1.SetString("MagicGopher")
	f2 := v1.FieldByName("Age")
	f2.SetInt(20)
	f3 := v1.FieldByName("School")
	f3.SetString("XXXå­¦æ ¡")
	fmt.Println("s1:", s1)
}
```

è¾“å‡ºç»“æœï¼š

```text
s1 ç±»å‹ï¼šmain.Student
p1 ç±»å‹ï¼š*main.Student
s1.Name: Gopher
*p1.Name: Gopher
v1.Elem æ˜¯å¦å¯ä»¥è®¾ç½®ï¼š true
s1: {MagicGopher 20 XXXå­¦æ ¡}
```

## åå°„è¿›è¡Œæ–¹æ³•è°ƒç”¨

è¿™ç®—æ˜¯ä¸€ä¸ªé«˜çº§ç”¨æ³•äº†ï¼Œå‰é¢æˆ‘ä»¬åªè¯´åˆ°å¯¹ç±»å‹ã€å˜é‡çš„å‡ ç§åå°„çš„ç”¨æ³•ï¼ŒåŒ…æ‹¬å¦‚ä½•è·å–å…¶å€¼ã€å…¶ç±»å‹ã€ä»¥åŠå¦‚ä½•é‡æ–°è®¾ç½®æ–°å€¼ã€‚ä½†æ˜¯åœ¨é¡¹ç›®åº”ç”¨ä¸­ï¼Œå¦å¤–ä¸€ä¸ªå¸¸ç”¨å¹¶ä¸”å±äºé«˜çº§çš„ç”¨æ³•ï¼Œå°±æ˜¯é€šè¿‡ reflect æ¥è¿›è¡Œã€Œæ–¹æ³•/å‡½æ•°ã€çš„è°ƒç”¨ã€‚æ¯”å¦‚æˆ‘ä»¬è¦åšæ¡†æ¶å·¥ç¨‹çš„æ—¶å€™ï¼Œéœ€è¦å¯ä»¥éšæ„æ‰©å±•æ–¹æ³•ï¼Œæˆ–è€…è¯´ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰æ–¹æ³•ï¼Œé‚£ä¹ˆæˆ‘ä»¬é€šè¿‡ä»€ä¹ˆæ‰‹æ®µæ¥æ‰©å±•è®©ç”¨æˆ·èƒ½å¤Ÿè‡ªå®šä¹‰å‘¢ï¼Ÿå…³é”®ç‚¹åœ¨äºç”¨æˆ·çš„è‡ªå®šä¹‰æ–¹æ³•æ˜¯æœªå¯çŸ¥çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡ reflect æ¥æå®šã€‚

è¿™é‡Œæ¶‰åŠåˆ° reflect åŒ…ä¸­ä¸€ä¸ªéå¸¸é‡è¦çš„æ–¹æ³•ï¼š

```go
// Call calls the function v with the input arguments in.
// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
// Call panics if v's Kind is not [Func].
// It returns the output results as Values.
// As in Go, each input argument must be assignable to the
// type of the function's corresponding input parameter.
// If v is a variadic function, Call creates the variadic slice parameter
// itself, copying in the corresponding values.

// è°ƒç”¨å‡½æ•° v æ—¶ï¼Œè¾“å…¥å‚æ•°ä¸º in
// ä¾‹å¦‚ï¼Œif len(in) == 3, v.Call(in) è¡¨ç¤º Go è°ƒç”¨ v(in[0]ï¼Œ in[1]ï¼Œ in[2])
// å¦‚æœ v çš„ Kind ä¸æ˜¯ Funcï¼Œåˆ™ panic
// å®ƒä»¥ Value[] è¿”å›è¾“å‡ºç»“æœ
// ä¸ Go ä¸€æ ·ï¼Œæ¯ä¸ªè¾“å…¥å‚æ•°å¿…é¡»å¯èµ‹å€¼ç»™å‡½æ•°å¯¹åº”çš„è¾“å…¥å‚æ•°çš„ç±»å‹
// å¦‚æœ v æ˜¯ä¸€ä¸ªå¯å˜å‚æ•°å‡½æ•°ï¼Œåˆ™è°ƒç”¨è‡ªå·±åˆ›å»ºå¯å˜å‚æ•°åˆ‡ç‰‡å½¢å‚ï¼Œå¤åˆ¶ç›¸åº”çš„å€¼
func (v Value) Call(in []Value) []Value {...}
```

**ï¼ˆ1ï¼‰é€šè¿‡åå°„ï¼Œè°ƒç”¨æ–¹æ³•**

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

type Person struct {
	Name string
	Age  uint
	Sex  string
}

func (p Person) Say(msg string) {
	fmt.Println("hello, ", msg)
}

func (p Person) PrintInfo() {
	fmt.Printf("å§“å: %s, å¹´é¾„: %d, æ€§åˆ«: %s\n", p.Name, p.Age, p.Sex)
}

func (p Person) TestPerson(i, j int, s string) {
	fmt.Println("Test:", i, j, s)
}

// å¦‚ä½•é€šè¿‡åå°„æ¥è¿›è¡Œæ–¹æ³•çš„è°ƒç”¨ï¼Ÿ
// æœ¬æ¥å¯ä»¥ç”¨ç»“æ„ä½“å¯¹è±¡.æ–¹æ³•åç§°()ç›´æ¥è°ƒç”¨çš„ï¼Œ
// ä½†æ˜¯å¦‚æœè¦é€šè¿‡åå°„ï¼Œ
// é‚£ä¹ˆé¦–å…ˆè¦å°†æ–¹æ³•æ³¨å†Œï¼Œä¹Ÿå°±æ˜¯ MethodByNameï¼Œç„¶åé€šè¿‡åå°„è°ƒåŠ¨ mv.Call
func main() {
	p1 := Person{"Gopher", 18, "ç”·"}

	//1. è¦é€šè¿‡åå°„æ¥è°ƒç”¨èµ·å¯¹åº”çš„æ–¹æ³•ï¼Œå¿…é¡»è¦å…ˆé€šè¿‡ reflect.ValueOf(interface) æ¥è·å–åˆ°reflect.Value
	//   å¾—åˆ°â€œåå°„ç±»å‹å¯¹è±¡â€åæ‰èƒ½åšä¸‹ä¸€æ­¥å¤„ç†
	getValue := reflect.ValueOf(p1)

	// 2. ä¸€å®šè¦æŒ‡å®šå‚æ•°ä¸ºæ­£ç¡®çš„æ–¹æ³•å
	// 2.1 å…ˆçœ‹çœ‹æ²¡æœ‰å‚æ•°çš„è°ƒç”¨æ–¹æ³•
	methodValue1 := getValue.MethodByName("PrintInfo")
	fmt.Printf("PrintInfo ---> Kind: %s, Type: %s\n", methodValue1.Kind(), methodValue1.Type())
	methodValue1.Call(nil)            // æ²¡æœ‰å‚æ•°ï¼Œç›´æ¥å†™nil
	args1 := make([]reflect.Value, 0) //æˆ–è€…åˆ›å»ºä¸€ä¸ªç©ºçš„åˆ‡ç‰‡ä¹Ÿå¯ä»¥
	methodValue1.Call(args1)

	// 2.2 æœ‰å‚æ•°çš„æ–¹æ³•è°ƒç”¨
	methodValue2 := getValue.MethodByName("Say")
	fmt.Printf("Say ---> Kind : %s, Type : %s\n", methodValue2.Kind(), methodValue2.Type())
	args2 := []reflect.Value{reflect.ValueOf("åå°„æœºåˆ¶")}
	methodValue2.Call(args2)

	methodValue3 := getValue.MethodByName("TestPerson")
	fmt.Printf("Test ---> Kind : %s, Type : %s\n", methodValue3.Kind(), methodValue3.Type())
	args3 := []reflect.Value{reflect.ValueOf(100), reflect.ValueOf(200), reflect.ValueOf("Hello")}
	methodValue3.Call(args3)
}
```

è¾“å‡ºç»“æœï¼š

```text
PrintInfo ---> Kind: func, Type: func()
å§“å: Gopher, å¹´é¾„: 18, æ€§åˆ«: ç”·
å§“å: Gopher, å¹´é¾„: 18, æ€§åˆ«: ç”·
Say ---> Kind : func, Type : func(string)
hello,  åå°„æœºåˆ¶
Test ---> Kind : func, Type : func(int, int, string)
Test: 100 200 Hello
```

**ï¼ˆ2ï¼‰é€šè¿‡åå°„ï¼Œè°ƒç”¨å‡½æ•°**

é¦–å…ˆæˆ‘ä»¬è¦å…ˆç¡®è®¤ä¸€ç‚¹ï¼Œå‡½æ•°åƒæ™®é€šçš„å˜é‡ä¸€æ ·ï¼Œä¹‹å‰çš„ç« èŠ‚ä¸­æˆ‘ä»¬åœ¨è®²åˆ°å‡½æ•°çš„æœ¬è´¨çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥æŠŠå‡½æ•°ä½œä¸ºä¸€ç§å˜é‡ç±»å‹çš„ï¼Œè€Œä¸”æ˜¯å¼•ç”¨ç±»å‹ã€‚å¦‚æœè¯´ Fun() æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆ f1 := Fun ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œé‚£ä¹ˆ f1 ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¦‚æœç›´æ¥è°ƒç”¨ f1()ï¼Œé‚£ä¹ˆè¿è¡Œçš„å°±æ˜¯ Fun() å‡½æ•°ã€‚

é‚£ä¹ˆæˆ‘ä»¬å°±å…ˆé€šè¿‡ ValueOf() æ¥è·å–å‡½æ•°çš„åå°„å¯¹è±¡ï¼Œå¯ä»¥åˆ¤æ–­å®ƒçš„ Kindï¼Œæ˜¯ä¸€ä¸ª funcï¼Œé‚£ä¹ˆå°±å¯ä»¥æ‰§è¡Œ Call() è¿›è¡Œå‡½æ•°çš„è°ƒç”¨ã€‚

ç¤ºä¾‹ï¼š

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// å‡½æ•°çš„åå°„
	f1 := fun1
	f1Value := reflect.ValueOf(f1)
	fmt.Printf("Kind: %s, Type: %s\n", f1Value.Kind(), f1Value.Type())

	f2 := fun2
	f2Value := reflect.ValueOf(f2)
	fmt.Printf("Kind: %s, Type: %s\n", f2Value.Kind(), f2Value.Type())

	// é€šè¿‡åå°„è°ƒç”¨å‡½æ•°
	f1Value.Call(nil) // æ²¡æœ‰å‚æ•°
	f2Value.Call([]reflect.Value{reflect.ValueOf(100), reflect.ValueOf("hello")})
}

func fun1() {
	fmt.Println("fun1()ï¼Œæ²¡æœ‰å‚æ•°.")
}

func fun2(i int, s string) {
	fmt.Println("fun2()ï¼Œæœ‰å‚æ•°.")
}
```

è¾“å‡ºç»“æœï¼š

```text
Kind: func, Type: func()
Kind: func, Type: func(int, string)
fun1()ï¼Œæ²¡æœ‰å‚æ•°.
fun2()ï¼Œæœ‰å‚æ•°.
```

ç¤ºä¾‹è¯´æ˜ï¼š

1. è¦é€šè¿‡åå°„æ¥è°ƒç”¨èµ·å¯¹åº”çš„æ–¹æ³•ï¼Œå¿…é¡»è¦å…ˆé€šè¿‡ `reflect.ValueOf(interface)` æ¥è·å–åˆ° `reflect.Value` å¾—åˆ°â€œåå°„ç±»å‹å¯¹è±¡â€åæ‰èƒ½åšä¸‹ä¸€æ­¥å¤„ç†ã€‚
2. `reflect.Value.MethodByName` è¿™ä¸ª `MethodByName`ï¼Œéœ€è¦æŒ‡å®šå‡†ç¡®çœŸå®çš„æ–¹æ³•åå­—ï¼Œå¦‚æœé”™è¯¯å°†ç›´æ¥ panicï¼Œ`MethodByName` è¿”å›ä¸€ä¸ªå‡½æ•°å€¼å¯¹åº”çš„ `reflect.Value` æ–¹æ³•çš„åå­—ã€‚
3. `[]reflect.Value` è¿™ä¸ªæ˜¯æœ€ç»ˆéœ€è¦è°ƒç”¨çš„æ–¹æ³•çš„å‚æ•°ï¼Œå¯ä»¥æ²¡æœ‰æˆ–è€…ä¸€ä¸ªæˆ–è€…å¤šä¸ªï¼Œæ ¹æ®å®é™…å‚æ•°æ¥å®šã€‚
4. `reflect.Value` çš„ `Call` è¿™ä¸ªæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å°†æœ€ç»ˆè°ƒç”¨çœŸå®çš„æ–¹æ³•ï¼Œå‚æ•°åŠ¡å¿…ä¿æŒä¸€è‡´ï¼Œå¦‚æœ `reflect.Value.Kind` ä¸æ˜¯ä¸€ä¸ªæ–¹æ³•ï¼Œé‚£ä¹ˆå°†ç›´æ¥ panicã€‚
5. æœ¬æ¥å¯ä»¥ç”¨å¯¹è±¡è®¿é—®æ–¹æ³•ç›´æ¥è°ƒç”¨çš„ï¼Œä½†æ˜¯å¦‚æœè¦é€šè¿‡åå°„ï¼Œé‚£ä¹ˆé¦–å…ˆè¦å°†æ–¹æ³•æ³¨å†Œï¼Œä¹Ÿå°±æ˜¯ `MethodByName`ï¼Œç„¶åé€šè¿‡åå°„è°ƒç”¨ `methodValue.Call`ã€‚

## å‚è€ƒèµ„æ–™

- [https://pkg.go.dev/reflect](https://pkg.go.dev/reflect)
- [https://hedon954.github.io/noteSite/](https://hedon954.github.io/noteSite/)